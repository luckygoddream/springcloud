# 面试记录
## 1.死锁的4个条件
- 互斥条件：任意时刻一个资源都只能给一个线程使用
- 不可剥夺条件：进程的资源在没使用完毕之前，不能被剥夺
- 请求与保持条件：进程已有资源然后又去获取新的已被别的进程持有的资源时，这时请求阻塞但是不会释放自己以已经获得的资源
- 循环等待条件：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源

## 2.nginx能否转发请求头有下滑线的资源
可以，需要在http模块添加underscores_in_headers on参数，nginx默认是过滤掉了带有下划线的变量，如果需要添加带有下划线的请求头，需把 underscores_in_headers 设置为 on

## 3.Linux怎么拆分大文件
- Linux split命令用来将一个文件分割成数个，默认情况下按1000行分割成小文件
- 语法：split [--help][--version][-<行数>][-b <字节>][-C <字节>][-l <行数>][要切割的文件][输出文件名]

## 4.新的任务提交到线程池，线程池怎么处理？
- 第一步 ：线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则执行第二步。
- 第二步 ：线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里进行等待。如果工作队列满了，则执行第三步。
- 第三步 ：线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给拒绝策略来处理这个任务。
- 即任务处理优先级：核心线程池的线程 > 工作队列 > 线程池的线程 > 拒绝策略

## 5.什么是快速失败？什么是安全失败？
- 快速失败（fail-fast）
  - 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。
  - 原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。
  - 注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。
  - 场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。
- 安全失败（fail-safe）
  - 采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。
  - 原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。
  - 缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。
  - 场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。

## 6.List查询结果集为空或者null的原因
- null的时候还没有分配内存，空的时候是已经分配了内存只是还没有写入值。

## 7.什么是内存泄露？什么是内存溢出？
- 内存溢出是指程序在申请内存时，没有足够的内存可以使用，出现out of memory
- 内存泄露是指程序在申请内存后，无法释放已经申请的内存，多次内存泄露会出现memory leak




## 8.PING命令使用的是什么协议？
- 使用的是ICMP协议，是“Internet Control Message Protocol”（Internet控制消息协议）的缩写，是TCP/IP协议族的一个子协议，用于在IP主机、 路由器之间传递控制消息

## 9.union和union all的区别
- union是将连接的两个查询结果表连接起来并做去重处理；
- union all是将连接的两个查询结果表连接起来；﻿
- 效率：
  - 对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，Union All不会去除重复记录。
  - 对排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回。
- 从效率上说，UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用UNION ALL。

## 10.FIFO队列
- First Input First Output的缩写，先入先出队列，这是一种传统的按序执行方法，先进入的指令先完成并引退，跟着才执行第二条指令。

## 11.锁的升级、降级
- 所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。
- 锁的级别由低到高依次为：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态

## 12.什么是Nginx粘连？
- 要求nginx将同一个用户的请求定向到指定一台机器上，同一个用户不管请求多少次，只要后端server没有发生变化，都分配到同一台机器上，这个需求用专业术语讲叫“粘连”。

## 13.hashmap计算hashcode时为什么要把高位右移16位
- 将编号超过数组16的元素放入数组，需要确定位置，这时位运算能快速的满足要求生成不超过数组长度的值来确定位置。

## 14.什么是缓存穿透 击穿 雪崩？
- 缓存穿透：缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。
- 缓存击穿：缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。
- 缓存雪崩：缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

## 15. 3.14E-4与3.14E+4表示什么？
- 3.14E-4表示3.14乘以10的负4次方
- 3.14E+4表示3.14乘以10的4次方

## 16. 类加载器
- 类加载器从低到高为：自定义类加载器->应用程序类加载器->扩展类加载器->应用类加载器

## 17. 