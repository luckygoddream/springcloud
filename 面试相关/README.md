# 面试记录
## 1.死锁的4个条件
- 互斥条件：任意时刻一个资源都只能给一个线程使用
- 不可剥夺条件：进程的资源在没使用完毕之前，不能被剥夺
- 请求与保持条件：进程已有资源然后又去获取新的已被别的进程持有的资源时，这时请求阻塞但是不会释放自己以已经获得的资源
- 循环等待条件：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源

## 2.nginx能否转发请求头有下滑线的资源
可以，需要在http模块添加underscores_in_headers on参数，nginx默认是过滤掉了带有下划线的变量，如果需要添加带有下划线的请求头，需把 underscores_in_headers 设置为 on

## 3.Linux怎么拆分大文件
- Linux split命令用来将一个文件分割成数个，默认情况下按1000行分割成小文件
- 语法：split [--help][--version][-<行数>][-b <字节>][-C <字节>][-l <行数>][要切割的文件][输出文件名]

## 4.新的任务提交到线程池，线程池怎么处理？
- 第一步 ：线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则执行第二步。
- 第二步 ：线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里进行等待。如果工作队列满了，则执行第三步。
- 第三步 ：线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给拒绝策略来处理这个任务。
- 即任务处理优先级：核心线程池的线程 > 工作队列 > 线程池的线程 > 拒绝策略

## 5.什么是快速失败？什么是安全失败？
- 快速失败（fail-fast）
  - 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。
  - 原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。
  - 注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。
  - 场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。
- 安全失败（fail-safe）
  - 采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。
  - 原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。
  - 缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。
  - 场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。

## 6.List查询结果集为空或者null的原因
- null的时候还没有分配内存，空的时候是已经分配了内存只是还没有写入值。

## 7.什么是内存泄露？什么是内存溢出？
- 内存溢出是指程序在申请内存时，没有足够的内存可以使用，出现out of memory
- 内存泄露是指程序在申请内存后，无法释放已经申请的内存，多次内存泄露会出现memory leak
- 内存溢出: out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；
- 内存泄露 :memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。

## 8.PING命令使用的是什么协议？
- 使用的是ICMP协议，是“Internet Control Message Protocol”（Internet控制消息协议）的缩写，是TCP/IP协议族的一个子协议，用于在IP主机、 路由器之间传递控制消息

## 9.union和union all的区别
- union是将连接的两个查询结果表连接起来并做去重处理；
- union all是将连接的两个查询结果表连接起来；
- 效率：
  - 对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，Union All不会去除重复记录。
  - 对排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回。
- 从效率上说，UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用UNION ALL。

## 10.FIFO队列
- First Input First Output的缩写，先入先出队列，这是一种传统的按序执行方法，先进入的指令先完成并引退，跟着才执行第二条指令。

## 11.锁的升级、降级
- 所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。
- 锁的级别由低到高依次为：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态

## 12.什么是Nginx粘连？
- 要求nginx将同一个用户的请求定向到指定一台机器上，同一个用户不管请求多少次，只要后端server没有发生变化，都分配到同一台机器上，这个需求用专业术语讲叫“粘连”。

## 13.hashmap计算hashcode时为什么要把高位右移16位
- 将编号超过数组16的元素放入数组，需要确定位置，这时位运算能快速的满足要求生成不超过数组长度的值来确定位置。

## 14.什么是缓存穿透 击穿 雪崩？
- 缓存穿透：缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。
- 缓存击穿：缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。
- 缓存雪崩：缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

## 15. 3.14E-4与3.14E+4表示什么？
- 3.14E-4表示3.14乘以10的负4次方
- 3.14E+4表示3.14乘以10的4次方

## 16. 类加载器
- 类加载器从低到高为：自定义类加载器->应用程序类加载器->扩展类加载器->根类加载器

## 17. redis的全称
- redis的全程是Remote Dictionary Server即远程字典服务

## 18.MySQL字符串与数字比较时如何转换？
- MySQL在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较

## 19.new一个类，类的执行顺序
- 静态代码块—非静态代码块—构造函数—一般方法。
- 子类继承父类各部分执行顺序为：父静态代码块--子静态代码块--父非静态代码--父无参构造函数--子非静态代码块--子构造函数--方法。 
- 注意：创建子类对象调用子类的构造方法的时候会先调用父类的构造方法，在子类的构造方法中调用父类的构造方法是用super()，如果没有写super()，则默认调用父类的无参构造方法。

## 20.类的加载流程
- 在java中，类型（类）的加载，连接与初始化都是在程序运行期间完成的。
- 加载：查找并加载类的二进制数据（将编译后.class数据加载到内存中）
- 连接：
   - 验证 ：确保加载类的正确性
   - 准备：给类的静态变量分配内存，并将其初始化为默认值
   - 解析：把类中的符号引用转换为直接引用
- 初始化：为类的静态变量赋予正确的初始值
- 使用
- 卸载
## 21.bit与byte的区别
- Bit 意为"位"或"比特"，是计算机运算的基础单位；Byte 意为"字节"，是计算机文件大小的基本计算单位；
- 1 bit 就是1位二进制数，比如 1 或者 0；1 Byte 就是 1 个字节，1 个字节是由 8 个二进制位组成的。比如1111111,00000000等。
- 8 bit = 1 Byte

## 22.临界资源和临界区
- 临界资源指在计算机程序中，每次只允许一个进程（线程）访问的资源，而每个进程（线程）访问临界资源的的那段代码称为临界区。

## 23.BIO、NIO、AIO
- 同步与异步
    - 同步：同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。
    - 异步：异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其它的请求，被调用者通常依靠事件、回调等机制来通知调用者其返回结果。
- 阻塞和非阻塞
    - 阻塞：阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其它任务，只有当条件就绪才能继续。
    - 非阻塞：非阻塞就是发起一个请求，调用者不用一直等待结果返回，可以先去干其它事情。
- BIO(Blocking I/O) : 同步阻塞I/O模型，数据的读取写入必须阻塞在一个线程内等待其完成。
- NIO (New I/O)  :
    - NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。
    - NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。
- AIO (Asynchronous I/O)  
    - AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。
    - AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。 
    - 目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。 
  
## 24 移位运算符
- 无符号位移>>> 例：100>>>2  将100转换为2进制右移两位

## 25 类加载器
- JVM中类加载器结构为树状层次结构
- Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。
- 引导类（根类）加载器（bootstrap class loader）： 
  - 它用来加载 Java 的核心库(jre/lib/rt.jar)，是用原生C++代码来实现的，并不继承自java.lang.ClassLoader。
  加载扩展类和应用程序类加载器，并指定他们的父类加载器，在java中获取不到。
- 扩展类加载器（extensions class loader）：
  - 它用来加载 Java 的扩展库(jre/ext/*.jar)。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。
- 系统（应用）类加载器（system class loader）：
  - 它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。
- 自定义类加载器（custom class loader）：
  - 除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。
- 双亲委派机制 
  - 某个特定的类加载器在接到加载类的请求时，首先将加载任务委托交给父类加载器，父类加载器又将加载任务向上委托，直到最父类加载器，如果最父类加载器可以完成类加载任务，就成功返回，如果不行就向下传递委托任务，由其子类加载器进行加载。
- 双亲委派机制的好处：
  - 保证java核心库的安全性（例如：如果用户自己写了一个java.lang.String类就会因为双亲委派机制不能被加载，不会破坏原生的String类的加载），采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
- 子加载器所加载的类是能够访问到父加载器所加载的类
- 父加载器所加载的类无法访问到子加载器所加载的类

- 内建于JVM中的启动类加载器会加载java.lang/ClassLoader以及其他的java平台类，当JVM启动时，一块特殊的机器码会执行，它会加载扩展类加载器和系统类加载器，这块特殊的机器码叫做启动类加载器（Bootstap)。启动类并不是java类，而其他的加载器都是java类。


## 26 java虚拟机生命周期结束条件
- 1.执行System.exit()方法
- 2.程序正常执行
- 3.程序执行过程遇到异常或错误而异常终止
- 4.由于操作系统出现错误而导致java虚拟机进程终止

## 27 Java程序对类的使用方式
- 1>主动使用（7种方式）创建类的实例、访问某个类或者接口的非final类型的静态变量/对该静态变量赋值、调用类的静态方法、反射、初始化一个类的子类、jvm启动时被标明为启动类的类（如Java Test、main方法所在的类）、jdk1.7开始提供动态语言的支持相关（很少使用）
- 2>被动使用（7种之外都是被动使用）不会初始化
- 所有的java程序虚拟机实现必须在每个类或接口被java程序“首次主动使用”时才初始化它们。
- 对于静态字段来说，只有直接定义了该字段的类才会被初始化。
- 当一个类初始化时，要求其所有父类也要初始化，并先初始化。
- 当一个接口在初始化时，并不要求其父接口也完成初始化。
- 当一个类初始化时，并不会初始化其实现的接口。
- 初始化一个接口时，并不会初始化它的父接口。

## 28 SpringBoot中有了属性文件为什么还要加一个bootstrap.yml文件?
- 在单体的SpringBoot项目中其实我们是用不到bootstrap.yml文件的，bootstrap.yml文件的使用需要SpringCloud的支持，因为在微服务环境下我们]都是有配置中心的，来统一的管理系统的相关配置属性， 那么怎么去加教配置中心的内容呢?一个SpringBoot项目启动的时候默认只会加载对应的application.yml中的相关信息，这时bootstrap.yml的作用就体现出来了，会在SpringBoot正常启动前创建一个父容器来通过bootstrap.yml中的配置来加载配置中心的内容。

## 29 锁的小知识
- 线程阻塞方法wait()与线程唤醒方法notify()必须配合synchronized使用
- Lock下的类线程阻塞方法await()与线程唤醒方法signal()

## 30 MySQL的Innodb引擎之行锁还是表锁
- 如果未命中索引会变为表锁，命中索引会变为行锁

## 31 Spring Boot中的@Order
- @Order是Spring框架提供的一种方式，用于控制应用程序中各个组件的加载顺序。通过指定@Order注解的值，你可以确保组件在应用程序启动时按照指定的顺序加载，这对于解决依赖关系和执行顺序很有用。